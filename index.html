<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FSL Client-Side AI (WASM Optimized)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@latest/dist/tf-backend-wasm.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        body { background: #222; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; }
        
        #container { position: relative; width: 100%; max-width: 480px; aspect-ratio: 4/3; border: 4px solid #444; border-radius: 12px; overflow: hidden; background: #000; }
        
        #videoElement { display: none; }
        #canvasElement { width: 100%; height: 100%; transform: scaleX(-1); }

        #overlay { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.6); padding: 10px; border-radius: 5px; text-align: left; pointer-events: none; }
        
        #status-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px #000; z-index: 20; pointer-events: none; text-align: center; }
        
        #progress-container { position: absolute; bottom: 0; left: 0; width: 100%; height: 15px; background: rgba(50, 50, 50, 0.8); }
        #progress-bar { height: 100%; width: 0%; background: #00ff00; transition: width 0.1s linear; }

        #prediction-box { margin-top: 15px; font-size: 18px; padding: 15px; background: #333; border-radius: 8px; width: 90%; max-width: 480px; text-align: center; }
        .highlight { color: #0f0; font-weight: bold; }
        
        /* Debug info for backend */
        #backend-info { position: fixed; bottom: 5px; right: 5px; font-size: 12px; color: #888; }
    </style>
</head>
<body>

    <h3>FSL AI (WASM + SIMD)</h3>

    <div id="container">
        <video id="videoElement" playsinline></video>
        <canvas id="canvasElement"></canvas>
        
        <div id="overlay">
            <div>Conf: <span id="conf">0.00</span></div>
            <div>Sign: <span id="curr" class="highlight">-</span></div>
        </div>

        <div id="status-display">INIT WASM...</div>

        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
    </div>

    <div id="prediction-box">Sentence: <span id="sentence">Waiting...</span></div>
    <div id="backend-info">Backend: Initializing...</div>

    <script>
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasCtx = canvasElement.getContext('2d');
        const progressBar = document.getElementById('progress-bar');
        const statusDisplay = document.getElementById('status-display');
        const currSpan = document.getElementById('curr');
        const confSpan = document.getElementById('conf');
        const sentSpan = document.getElementById('sentence');
        const backendInfo = document.getElementById('backend-info');

        let model;
        let labels = [];
        let sequence = [];
        let sentence = [];
        
        const SEQUENCE_LENGTH = 60; 
        const THRESHOLD = 0.8;

        const STATE_PREP = 0;
        const STATE_RECORD = 1;
        const STATE_RESULT = 2;
        let currentState = STATE_PREP;
        let phaseStartTime = 0;

        // --- 1. SETUP WASM BACKEND & LOAD MODEL ---
        async function loadAssets() {
            statusDisplay.innerText = "LOADING WASM...";
            
            try {
                // EXPLICITLY SET WASM PATHS (Fixes CDN issues)
                // This points to the .wasm binary files on the CDN
                tf.wasm.setWasmPaths('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@latest/dist/');
                
                // FORCE BACKEND TO WASM
                await tf.setBackend('wasm');
                await tf.ready(); // Wait for it to initialize

                // Check if it worked
                const currentBackend = tf.getBackend();
                console.log("Current TF Backend:", currentBackend);
                backendInfo.innerText = `Backend: ${currentBackend.toUpperCase()}`;

                statusDisplay.innerText = "LOADING MODEL...";
                
                // Load Model
                model = await tf.loadLayersModel('model/model.json');
                
                // Warmup the model (runs 1 dummy prediction to compile shaders/wasm)
                const zeroTensor = tf.zeros([1, 60, 126]);
                model.predict(zeroTensor).dispose();
                zeroTensor.dispose();

                // Load Labels
                const response = await fetch('js/labels.json');
                labels = await response.json();
                
                statusDisplay.innerText = "STARTING CAM...";
                startCamera();

            } catch (err) {
                console.error("Setup Error:", err);
                statusDisplay.innerText = "ERROR";
                backendInfo.innerText = "Error: " + err.message;
            }
        }

        // --- 2. KEYPOINT EXTRACTION (Holistic) ---
        function extractKeypoints(results) {
            const getHand = (landmarks) => {
                if (landmarks) {
                    let flat = [];
                    for (const lm of landmarks) flat.push(lm.x, lm.y, lm.z);
                    return flat;
                } else {
                    return new Array(21 * 3).fill(0);
                }
            };
            const lh = getHand(results.leftHandLandmarks);
            const rh = getHand(results.rightHandLandmarks);
            return [...lh, ...rh];
        }

        // --- 3. MEDIAPIPE LOOP ---
        function onResults(results) {
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#CC0000', lineWidth: 3});
            drawLandmarks(canvasCtx, results.leftHandLandmarks, {color: '#00FF00', lineWidth: 1});
            drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00CC00', lineWidth: 3});
            drawLandmarks(canvasCtx, results.rightHandLandmarks, {color: '#FF0000', lineWidth: 1});
            canvasCtx.restore();

            const now = Date.now();
            if (phaseStartTime === 0) phaseStartTime = now;
            const elapsed = now - phaseStartTime;

            if (currentState === STATE_PREP) {
                const progress = Math.min(elapsed / 2000, 1.0) * 100;
                progressBar.style.width = progress + "%";
                progressBar.style.backgroundColor = "yellow";
                statusDisplay.innerText = "GET READY";
                statusDisplay.style.color = "yellow";
                if (elapsed >= 2000) { currentState = STATE_RECORD; phaseStartTime = Date.now(); sequence = []; }

            } else if (currentState === STATE_RECORD) {
                const progress = Math.min(elapsed / 2000, 1.0) * 100;
                progressBar.style.width = progress + "%";
                progressBar.style.backgroundColor = "red";
                statusDisplay.innerText = "RECORDING";
                statusDisplay.style.color = "red";

                const keypoints = extractKeypoints(results);
                sequence.push(keypoints);

                if (elapsed >= 2000) { currentState = STATE_RESULT; phaseStartTime = Date.now(); runPrediction(); }

            } else if (currentState === STATE_RESULT) {
                const progress = Math.min(elapsed / 2000, 1.0) * 100;
                progressBar.style.width = (100 - progress) + "%";
                progressBar.style.backgroundColor = "#00ff00";
                statusDisplay.style.color = "#00ff00";
                if (elapsed >= 2000) { currentState = STATE_PREP; phaseStartTime = Date.now(); }
            }
        }

        // --- 4. PREDICTION LOGIC ---
        async function runPrediction() {
            if (sequence.length < 5) return; 
            
            let finalSeq = [];
            if (sequence.length >= SEQUENCE_LENGTH) {
                finalSeq = sequence.slice(sequence.length - SEQUENCE_LENGTH);
            } else {
                const paddingCount = SEQUENCE_LENGTH - sequence.length;
                const zeroFrame = new Array(126).fill(0);
                for(let i=0; i<paddingCount; i++) finalSeq.push(zeroFrame);
                finalSeq = finalSeq.concat(sequence);
            }

            // Tidy is crucial in WASM to prevent memory leaks!
            tf.tidy(() => {
                const inputTensor = tf.tensor3d([finalSeq]);
                const prediction = model.predict(inputTensor);
                const values = prediction.dataSync(); // Sync is okay in WASM/Tidy
                
                const maxVal = Math.max(...values);
                const maxIndex = values.indexOf(maxVal);
                const predictedSign = labels[maxIndex];

                confSpan.innerText = maxVal.toFixed(2);

                if (maxVal > THRESHOLD) {
                    currSpan.innerText = predictedSign;
                    statusDisplay.innerText = predictedSign;
                    if (sentence.length === 0 || predictedSign !== sentence[sentence.length - 1]) {
                        sentence.push(predictedSign);
                        if (sentence.length > 5) sentence.shift();
                        sentSpan.innerText = sentence.join(" ");
                    }
                } else {
                    currSpan.innerText = "...";
                    statusDisplay.innerText = "LOW CONFIDENCE";
                }
            });
        }

        // --- 5. INITIALIZE MEDIAPIPE ---
        const holistic = new Holistic({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;
        }});
        
        holistic.setOptions({
            modelComplexity: 0, // 0 = Lite (Best for Mobile WASM)
            smoothLandmarks: true,
            enableSegmentation: false,
            enableFaceMesh: false,
            refineFaceLandmarks: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        holistic.onResults(onResults);

        function startCamera() {
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await holistic.send({image: videoElement});
                },
                width: 480,
                height: 360
            });
            camera.start();
        }

        loadAssets();
    </script>
</body>
</html>