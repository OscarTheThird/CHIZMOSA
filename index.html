<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FSL Progress Bar â€” Mode A (Max Smoothness)</title>

<!-- TF.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@latest/dist/tf-backend-wasm.js"></script>

<!-- MediaPipe Hands & drawing utils -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<style>
  body { background:#000; color:#0f0; font-family:monospace; display:flex; flex-direction:column; align-items:center; height:100vh; margin:0; overflow:hidden; }
  #container { position:relative; width:100%; max-width:640px; aspect-ratio:4/3; border:2px solid #333; background:#111; }
  #videoElement { display:none; }
  #canvasElement { width:100%; height:100%; transform:scaleX(-1); image-rendering:pixelated; }
  #ui-layer { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; padding:10px; display:flex; flex-direction:column; justify-content:space-between; }
  .stat-box { background:rgba(0,0,0,0.6); padding:4px 8px; border-radius:4px; pointer-events:auto; font-size:14px; margin-bottom:4px; width:fit-content; }
  #status-msg { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; text-shadow:0 2px 4px #000; width:100%; pointer-events:none; font-weight:bold; }
  #progress-container { width:100%; max-width:640px; height:10px; background:#333; margin-top:5px; border-radius:5px; overflow:hidden; }
  #progress-bar { height:100%; width:0%; transition:width .1s linear, background-color .2s; }
  .phase-ready{font-size:3rem;color:#FFD700;} .phase-rec{font-size:3rem;color:#FF0000;} .phase-result{font-size:4rem;color:#00FF00;background:rgba(0,0,0,0.7);padding:10px;}
  #controls{padding:10px;width:100%;display:flex;flex-wrap:wrap;gap:8px;justify-content:center;background:#111;border-top:1px solid #333;margin-top:10px;}
  button{background:#333;color:white;border:1px solid #555;padding:8px 12px;border-radius:4px;font-size:12px;cursor:pointer;} button.active{border-color:#0f0;color:#0f0;background:#000;}
  #prediction-history{font-size:1.2rem;color:#fff;margin-top:5px;text-align:center;width:100%;min-height:30px;}
</style>
</head>
<body>
  <div id="container">
    <video id="videoElement" playsinline></video>
    <canvas id="canvasElement"></canvas>

    <div id="ui-layer">
      <div>
        <div class="stat-box">FPS: <span id="fps-val">0</span></div>
        <div class="stat-box">Phase: <span id="phase-val">INIT</span></div>
      </div>
      <div id="status-msg">LOADING...</div>
      <div style="position:absolute; bottom:10px; right:10px; text-align:right;">
        <div class="stat-box">Conf: <span id="conf-val">0.00</span></div>
      </div>
    </div>
  </div>

  <div id="progress-container"><div id="progress-bar"></div></div>
  <div id="prediction-history"><span id="sentence">...</span></div>

  <div id="controls">
    <button id="btn-wasm" onclick="setBackend('wasm')">WASM</button>
    <button id="btn-webgl" onclick="setBackend('webgl')">WebGL</button>
    <button id="btn-swap" onclick="toggleSwap()">Swap L/R</button>
    <button onclick="toggleSkeleton()">Toggle Lines</button>
  </div>

<script>
const CONFIG = {
  SEQUENCE_LENGTH: 60,
  THRESHOLD: 0.8,
  WIDTH: 640,
  HEIGHT: 350,
  PROCESS_WIDTH: 256,    // smaller for smoothness
  PROCESS_HEIGHT: 224,
  TARGET_MS: 83,         // ~12 FPS processing (83 ms)
  MAX_NUM_HANDS: 1
};

const video = document.getElementById('videoElement');
const canvas = document.getElementById('canvasElement');
const ctx = canvas.getContext('2d');
const statusMsg = document.getElementById('status-msg');
const fpsVal = document.getElementById('fps-val');
const phaseVal = document.getElementById('phase-val');
const confVal = document.getElementById('conf-val');
const sentSpan = document.getElementById('sentence');
const progressBar = document.getElementById('progress-bar');

let model, hands;
let labels = [];
let sequence = [];
let sentence = [];
let isProcessing = false;
let isSwapMode = false;
let showSkeleton = true;

let currentPhase = 'LOADING';
let phaseStartTime = 0;
let lastFrameTime = performance.now();
let lastProcess = 0;
let lastFPS = 0;
let lastPredictionText = '';

const PHASE_DURATIONS = {READY:2000, RECORDING:2000, RESULT:2000};

// small canvas for MediaPipe input
const smallCanvas = document.createElement('canvas');
smallCanvas.width = CONFIG.PROCESS_WIDTH;
smallCanvas.height = CONFIG.PROCESS_HEIGHT;
const smallCtx = smallCanvas.getContext('2d');

async function init(){
  await setBackend('webgl'); // default to WebGL
  await loadModel();
}

async function setBackend(type){
  statusMsg.innerText = 'SWITCHING ENGINE...';
  try {
    if (type === 'wasm') {
      try { tf.wasm.setWasmPaths('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@latest/dist/'); } catch(e){}
    }
    await tf.setBackend(type);
    await tf.ready();
    document.getElementById('btn-wasm').className = type === 'wasm' ? 'active' : '';
    document.getElementById('btn-webgl').className = type === 'webgl' ? 'active' : '';
    statusMsg.innerText = 'ENGINE: ' + type.toUpperCase();
    setTimeout(()=>{ if (currentPhase === 'LOADING') statusMsg.innerText = 'READY TO START'; }, 600);
  } catch (err) {
    console.error('setBackend error:', err);
    alert('Failed to set backend: ' + err.message);
  }
}

async function loadModel(){
  statusMsg.innerText = 'LOADING MODEL...';
  try {
    model = await tf.loadLayersModel('model/model.json');
    tf.tidy(()=> model.predict(tf.zeros([1, CONFIG.SEQUENCE_LENGTH, 126])));
    const lblRes = await fetch('js/labels.json');
    labels = await lblRes.json();
    setupMediaPipe();
  } catch(e){
    statusMsg.innerText = 'LOAD ERROR';
    console.error(e);
  }
}

function setupMediaPipe(){
  hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
  // Mode A: smoothness, less complexity, smaller input
  hands.setOptions({
    maxNumHands: CONFIG.MAX_NUM_HANDS,
    modelComplexity: 0,
    minDetectionConfidence: 0.35,
    minTrackingConfidence: 0.35
  });
  hands.onResults(onResults);
  startCamera();
}

async function startCamera(){
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { width: CONFIG.WIDTH, height: CONFIG.HEIGHT, facingMode: 'user', frameRate: { max: 30 } }
    });
    video.srcObject = stream;
    video.onloadedmetadata = ()=>{
      video.play();
      canvas.width = CONFIG.WIDTH;
      canvas.height = CONFIG.HEIGHT;
      currentPhase = 'READY';
      phaseStartTime = Date.now();
      statusMsg.innerText = '';
      requestAnimationFrame(loop);
    };
  } catch(err){
    console.error('Camera error:', err);
    statusMsg.innerText = 'CAMERA ERROR';
  }
}

function loop(now){
  // render UI (video) every frame
  ctx.drawImage(video, 0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

  // fps smoothing
  const dt = now - lastFrameTime;
  lastFrameTime = now;
  if (dt > 0){
    const fps = 1000/dt;
    lastFPS = lastFPS ? (lastFPS*0.85 + fps*0.15) : fps;
    fpsVal.innerText = Math.round(lastFPS);
  }

  // time-based throttle for MediaPipe
  if (!isProcessing && (now - lastProcess) >= CONFIG.TARGET_MS){
    lastProcess = now;
    isProcessing = true;
    smallCtx.drawImage(video, 0, 0, CONFIG.PROCESS_WIDTH, CONFIG.PROCESS_HEIGHT);
    hands.send({ image: smallCanvas }).then(()=> {
      isProcessing = false;
    }).catch((err)=> {
      console.error('hands.send error:', err);
      isProcessing = false;
    });
  }

  requestAnimationFrame(loop);
}

function onResults(results){
  // only draw landmarks when results exist
  if (showSkeleton && results.multiHandLandmarks) {
    for (const landmarks of results.multiHandLandmarks) {
      drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color:'#00FF00', lineWidth:1 });
      drawLandmarks(ctx, landmarks, { color:'#FF0000', lineWidth:1, radius:2 });
    }
  }

  // update UI/phase
  const now = Date.now();
  const timeInPhase = now - phaseStartTime;
  let progress = 0; let barColor = '#333';
  if (currentPhase === 'READY') {
    progress = Math.min(100, (timeInPhase / PHASE_DURATIONS.READY) * 100);
    barColor = '#FFD700'; updateUI('READY','GET READY','phase-ready'); phaseVal.innerText = 'READY';
    if (timeInPhase > PHASE_DURATIONS.READY) { currentPhase = 'RECORDING'; phaseStartTime = now; sequence = []; }
  } else if (currentPhase === 'RECORDING') {
    progress = Math.min(100, (timeInPhase / PHASE_DURATIONS.RECORDING) * 100);
    barColor = '#FF0000'; updateUI('REC','RECORDING...','phase-rec'); phaseVal.innerText = 'REC';
    const keypoints = extractKeypoints(results); sequence.push(keypoints);
    if (timeInPhase > PHASE_DURATIONS.RECORDING) { performPrediction(); currentPhase = 'RESULT'; phaseStartTime = now; }
  } else if (currentPhase === 'RESULT') {
    progress = 100; barColor = '#00FF00'; updateUI('RESULT', lastPredictionText, 'phase-result'); phaseVal.innerText = 'RESULT';
    if (timeInPhase > PHASE_DURATIONS.RESULT) { currentPhase = 'READY'; phaseStartTime = now; statusMsg.innerText = ''; lastPredictionText = ''; }
  }

  progressBar.style.width = progress + '%';
  progressBar.style.backgroundColor = barColor;
  fpsVal.innerText = Math.max(1, Math.round(lastFPS || 0));
}

async function performPrediction(){
  if (sequence.length === 0) { lastPredictionText = 'No Data'; confVal.innerText = '0.00'; return; }
  let inputData = [...sequence];
  while (inputData.length < CONFIG.SEQUENCE_LENGTH) inputData.push(inputData[inputData.length-1] || new Array(126).fill(0));
  if (inputData.length > CONFIG.SEQUENCE_LENGTH) inputData = inputData.slice(inputData.length - CONFIG.SEQUENCE_LENGTH);
  try {
    tf.tidy(()=> {
      const input = tf.tensor3d([inputData]);
      const pred = model.predict(input);
      const values = pred.dataSync();
      const maxVal = Math.max(...values);
      const idx = values.indexOf(maxVal);
      confVal.innerText = maxVal.toFixed(2);
      if (maxVal > CONFIG.THRESHOLD) {
        const word = labels[idx];
        lastPredictionText = word.toUpperCase(); addToSentence(word);
      } else {
        lastPredictionText = 'UNCERTAIN';
      }
    });
  } catch(err) { console.error('Prediction error:', err); }
}

function updateUI(phase, text, cssClass){ statusMsg.className = cssClass; statusMsg.innerText = text; }
function addToSentence(word){ sentence.push(word); if (sentence.length>8) sentence.shift(); sentSpan.innerText = sentence.join(' '); }

function extractKeypoints(results) {
  let lh = new Array(63).fill(0);
  let rh = new Array(63).fill(0);
  if (results.multiHandLandmarks && results.multiHandedness) {
    for (let i=0;i<results.multiHandLandmarks.length;i++){
      let label = results.multiHandedness[i].label;
      if (isSwapMode) label = (label === 'Left') ? 'Right' : 'Left';
      const lm = results.multiHandLandmarks[i];
      const flat = [];
      for (const p of lm) flat.push(p.x, p.y, p.z);
      if (label === 'Left') lh = flat; else rh = flat;
    }
  }
  return [...lh, ...rh];
}

function toggleSwap(){ isSwapMode = !isSwapMode; document.getElementById('btn-swap').className = isSwapMode ? 'active' : ''; }
function toggleSkeleton(){ showSkeleton = !showSkeleton; }

init();
</script>
</body>
</html>
